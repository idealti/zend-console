{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deprecated! Both the zend-console and the zend-mvc-console components will likely not be maintained long-term, as there are more complete implementations available elsewhere. We strongly urge developers to start migrating their console tooling to use other libraries, such as symfony/console . Installation $ composer require zendframework/zend-console","title":"Home"},{"location":"#installation","text":"$ composer require zendframework/zend-console","title":"Installation"},{"location":"adapter/","text":"Console Adapters zend-console's console abstraction layer works around various bugs and limitations in operating systems, including: display of colorized text. discovery and calculation of console window size. discovery of console charset. basic line drawing capabilities. Console adapters implement Zend\\Console\\Adapter\\AdapterInterface , and you should typehint against that interface for purposes of working with console capabilities. Adapters are included for: Posix (*nix-based systems) Windows (and Windows ANSI; for use with command.bat ) Virtual (which provides Windows PowerShell compatibility) Retrieving the console adapter While you may know your current environment, you will want to write your code in such a way that the console adapter is specific to whatever environment it is run within. As such, you likely should never instantiate an adapter directly. zend-console, and the zend-mvc integration, provide tools for retrieving an appropriate adapter for the current environment in a generic way. Standalone zend-console provides a factory for creating and returning the console adapter specific to your environment: use Zend\\Console\\Console; use Zend\\Console\\Exception\\ExceptionInterface as ConsoleException; try { $console = Console::getInstance(); } catch (ConsoleException $e) { // Could not get console adapter; most likely we are not running inside a // console window. } This returns a Zend\\Console\\Adapter\\AdapterInterface implementation suitable for your current environment. Exceptions For practical and security reasons, Console::getInstance() will always throw an exception if you attempt to get console instance in a non-console environment (i.e. when running on a HTTP server). You can override this behavior by manually instantiating one of the Zend\\Console\\Adapter\\* classes; you should do this only as a last resort, however! zend-mvc If you are using MVC controllers you can obtain Console adapter instance using the ServiceManager . namespace Application; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\Console\\Adapter\\AdapterInterface as Console; use Zend\\Console\\Exception\\RuntimeException; class ConsoleController extends AbstractActionController { public function testAction() { $console = $this->getServiceLocator()->get('console'); if (! $console instanceof Console) { throw new RuntimeException('Cannot obtain console adapter. Are we running in a console?'); } } } If you extend AbstractConsoleController , you can use the getConsole() method instead: namespace Application; use Zend\\Mvc\\Controller\\AbstractConsoleController; use Zend\\Console\\Exception\\RuntimeException; class ConsoleController extends AbstractConsoleController { public function testAction() { $console = $this->getConsole(); } } Use dependency injection We recommend using dependency injection. Instead of pulling the console adapter from the service manager, inject it from within your controller's factory. This is essentially what happens when extending AbstractConsoleController already. Using the console adapter Zend\\Console\\Adapter\\AdapterInterface describes a rich set of capabilities. Below is a sampling. Window size and title Method Description $console->getWidth() (int) Get real console window width in characters. $console->getHeight() (int) Get real console window height in characters. $console->getSize() (array) Returns [$width, $height] with current console window dimensions. $console->getTitle() (string) Get console window title. Multibyte sequences For UTF-8 enabled consoles, dimensions represent the number of multibyte characters (real characters). Virtual buffer sizes On consoles with virtual buffers (e.g. MS Windows Command Prompt), width and height represent visible (real) size, without scrolling the window. For example, if the window scrolling width is 120 chars, but its real, visible width is 80 chars, getWidth() will return 80 . Character set Method Description $console->isUtf8() (boolean) Is the console UTF-8 compatible (can it display unicode strings)? $console->getCharset() ( Zend\\Console\\Charset\\CharsetInterface ) This method will return an instance of one of the Zend\\Console\\Charset\\* classes representing the readable charset present for line-drawing. It is automatically detected by the adapter. Writing to the console Method Description $console->write(string $text, $color = null, $bgColor = null) Write $text to the console, optionally using foreground $color and background $bgColor . Color values must be one of the Zend\\Console\\ColorInterface constants. $console->writeLine(string $text, $color = null, $bgColor = null) Write a single line of $text to the console. This method will output an environment-specific newline character at the end of the text, moving the console cursor to next line. $console->writeAt(string $text, int $x, int $y, $color = null, $bgColor = null) Write $text at the specified $x and $y coordinates of console window. The top left corner of the screen has coordinates of $x = 1; $y = 1 . To retrieve the far-right and bottom coordinates, use the getWidth() and getHeight() methods. Reading from the console Method Description $console->readChar(string $mask = null) (string) Read a single character from the console. Optional (string) $mask can be provided to force entering only a selected set of characters. For example, to read a single digit, we can use the following syntax: $digit = $console->readChar('0123456789'); . $console->readLine(int $maxLength = 2048) (string) Read a single line of input from console. Optional (int) $maxLength can be used to limit the length of data that will be read. The line will be returned without trailing newline characters . Miscellaneous Method Description $console->hideCursor() Hide blinking cursor from the console. $console->showCursor() Show blinking cursor in the console. $console->clear() Clear the screen. $console->clearLine() Clear the line that the cursor currently sits at.","title":"Console Adapters"},{"location":"adapter/#console-adapters","text":"zend-console's console abstraction layer works around various bugs and limitations in operating systems, including: display of colorized text. discovery and calculation of console window size. discovery of console charset. basic line drawing capabilities. Console adapters implement Zend\\Console\\Adapter\\AdapterInterface , and you should typehint against that interface for purposes of working with console capabilities. Adapters are included for: Posix (*nix-based systems) Windows (and Windows ANSI; for use with command.bat ) Virtual (which provides Windows PowerShell compatibility)","title":"Console Adapters"},{"location":"adapter/#retrieving-the-console-adapter","text":"While you may know your current environment, you will want to write your code in such a way that the console adapter is specific to whatever environment it is run within. As such, you likely should never instantiate an adapter directly. zend-console, and the zend-mvc integration, provide tools for retrieving an appropriate adapter for the current environment in a generic way.","title":"Retrieving the console adapter"},{"location":"adapter/#using-the-console-adapter","text":"Zend\\Console\\Adapter\\AdapterInterface describes a rich set of capabilities. Below is a sampling.","title":"Using the console adapter"},{"location":"intro/","text":"Introduction zend-console provides both generic support for routable console applications, as well as the basis for adding console support to zend-mvc-based applications. When a zend-mvc application is run from a console window (a shell window or Windows command prompt), it will recognize this fact and prepare zend-mvc components to handle the request. Console support is enabled by default, but to function properly it requires at least one console route and one action controller to handle the request. Alternately, you can build console-aware applications that are standalone; zf-console provides a standardized workflow for doing so. Features in zend-console include: Console routing allows you to invoke handlers (including controller actions) depending on command line parameters provided by the user. Console adapters provide abstraction for interacting with consoles exposed by different operating systems. Console prompts allow user interaction by asking questions and retrieving input. When used with zend-mvc , the following features are also available: Module Manager integration allows zend-mvc applications and modules to display help and usage information, either on demand, or in situations where no route was matched. Console-aware action controllers will receive a console request containing all named parameters and flags. They are able to send output back to the console window. Quick Start with zend-mvc The following example details integration of zend-console with zend-mvc. However, all information pertaining to routing can also be used without zend-mvc, but requires that you react to the routing results yourself. The aforementioned zf-console provides some basic wiring around that, and can and should be consulted if you do not choose to use zend-console with zend-mvc. A console route defines required and optional command line parameters. When a route matches, it returns an array of matched parameters \u2014 which may include default parameters, or even parameters not exposed via the command line (e.g., metadata related to the route). Let's assume that we'd like our application to handle the following command line: $ zf user resetpassword user@mail.com When a user runs our application ( zf ) with these parameters, we'd like to call the action resetpassword of Application\\Controller\\IndexController . The zf command We will use zf to depict the entry point for your application; it can be a shell script in the application's bin/ directory, or simply an alias for php public/index.php . First we need to create a route definition : user resetpassword <userEmail> This simple route definition expects exactly three arguments: the literal \"user\", the literal \"resetpassword\", and the dynamic argument we're calling \"userEmail\". Let's assume we also accept one optional parameter to enable verbose operation: user resetpassword [--verbose|-v] <userEmail> The modified console route above expects the same three arguments from our original example, but will also recognise an optional --verbose flag, or its shorthand version, -v . Flag Order The order of flags is ignored by zend-console. Flags can appear before positional parameters, after them, or anywhere in between. The order of multiple flags is also irrelevant. This applies both to route definitions and the order that flags are used on the command line. Let's use the definition above and configure our console route. When using zend-mvc, console routes are defined using the following configuration structure: return [ 'router' => [ 'routes' => [ // HTTP routes are defined here ], ], 'console' => [ 'router' => [ 'routes' => [ // Console routes go here ], ], ], /* ... */ ]; Let's create our console route and point it to Application\\Controller\\IndexController::resetpasswordAction() : // We could define routes for Application\\Controller\\IndexController in // the Application module config file, usually located at // modules/application/config/module.config.php, or in one of the // config/autoload/*.php files. return [ 'console' => [ 'router' => [ 'routes' => [ 'user-reset-password' => [ 'options' => [ 'route' => 'user resetpassword [--verbose|-v] <userEmail>', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'resetpassword', ], ], ], ], ], ], /* ... */ ; Handling Console Requests When a user runs our application from the command line and arguments match our console route, the specified controller will be instantiated, and the specified action method will be called, just as happens with zend-mvc HTTP requests. As such, let's add the resetpassword action to our Application\\Controller\\IndexController : namespace Application\\Controller; use RuntimeException; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use Zend\\Math\\Rand; class IndexController extends AbstractActionController { /* ... */ public function resetpasswordAction() { $request = $this->getRequest(); // Make sure that we are running in a console, and the user has not // tricked our application into running this action from a public web // server: if (! $request instanceof ConsoleRequest) { throw new RuntimeException('You can only use this action from a console!'); } // Get user email from the console, and check if the user requested // verbosity: $userEmail = $request->getParam('userEmail'); $verbose = $request->getParam('verbose') || $request->getParam('v'); // Reset new password $newPassword = Rand::getString(16); // Fetch the user and change his password, then email him ... /* ... */ if ($verbose) { return \"Done! New password for user $userEmail is '$newPassword'. \" . \"It has also been emailed to him.\\n\"; } return \"Done! $userEmail has received an email with his new password.\\n\"; } } The above creates resetpasswordAction() , which: retrieves the current request; checks if it's really coming from the console (as a precaution); in this example, we do not want our action to be invocable from a web page; pulls console arguments via $request->getParam() ; flags are represented by boolean values, where true means the flag was used, and false means otherwise; performs work based on the arguments; and finally returns a simple string to display to the user via the console. Adding Console Usage Info Console applications commonly display usage information when run without arguments. The combination of zend-console and zend-mvc enables this out of the box. Modules can provide usage information, and zend-console will query all loaded modules for console usage information they expose. Let's modify our Application\\Module to provide usage info: namespace Application; use Zend\\ModuleManager\\Feature\\AutoloaderProviderInterface; use Zend\\ModuleManager\\Feature\\ConfigProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; /** * Implementing ConsoleUsageProviderInterface allows the Module to provide * console usage information. */ class Module implements AutoloaderProviderInterface, ConfigProviderInterface, ConsoleUsageProviderInterface { public function getConfig() { /* ... */ } public function getAutoloaderConfig() { /* ... */ } public function getConsoleUsage(Console $console) { return [ // Describe available commands 'user resetpassword [--verbose|-v] EMAIL' => 'Reset password for a user', // Describe expected parameters [ 'EMAIL', 'Email of the user for a password reset' ], [ '--verbose|-v', '(optional) turn on verbose mode' ], ]; } } Each module that implements ConsoleUsageProviderInterface will be queried for console usage info. On route mismatch, all info from all modules will be concatenated, formatted to console width, and shown to the user. Usage Order The order of usage info displayed in the console is in the same order in which modules load. If you want your application to display important usage info first, change the order your modules are loaded.","title":"Introduction"},{"location":"intro/#introduction","text":"zend-console provides both generic support for routable console applications, as well as the basis for adding console support to zend-mvc-based applications. When a zend-mvc application is run from a console window (a shell window or Windows command prompt), it will recognize this fact and prepare zend-mvc components to handle the request. Console support is enabled by default, but to function properly it requires at least one console route and one action controller to handle the request. Alternately, you can build console-aware applications that are standalone; zf-console provides a standardized workflow for doing so. Features in zend-console include: Console routing allows you to invoke handlers (including controller actions) depending on command line parameters provided by the user. Console adapters provide abstraction for interacting with consoles exposed by different operating systems. Console prompts allow user interaction by asking questions and retrieving input. When used with zend-mvc , the following features are also available: Module Manager integration allows zend-mvc applications and modules to display help and usage information, either on demand, or in situations where no route was matched. Console-aware action controllers will receive a console request containing all named parameters and flags. They are able to send output back to the console window.","title":"Introduction"},{"location":"intro/#quick-start-with-zend-mvc","text":"The following example details integration of zend-console with zend-mvc. However, all information pertaining to routing can also be used without zend-mvc, but requires that you react to the routing results yourself. The aforementioned zf-console provides some basic wiring around that, and can and should be consulted if you do not choose to use zend-console with zend-mvc. A console route defines required and optional command line parameters. When a route matches, it returns an array of matched parameters \u2014 which may include default parameters, or even parameters not exposed via the command line (e.g., metadata related to the route). Let's assume that we'd like our application to handle the following command line: $ zf user resetpassword user@mail.com When a user runs our application ( zf ) with these parameters, we'd like to call the action resetpassword of Application\\Controller\\IndexController .","title":"Quick Start with zend-mvc"},{"location":"intro/#handling-console-requests","text":"When a user runs our application from the command line and arguments match our console route, the specified controller will be instantiated, and the specified action method will be called, just as happens with zend-mvc HTTP requests. As such, let's add the resetpassword action to our Application\\Controller\\IndexController : namespace Application\\Controller; use RuntimeException; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use Zend\\Math\\Rand; class IndexController extends AbstractActionController { /* ... */ public function resetpasswordAction() { $request = $this->getRequest(); // Make sure that we are running in a console, and the user has not // tricked our application into running this action from a public web // server: if (! $request instanceof ConsoleRequest) { throw new RuntimeException('You can only use this action from a console!'); } // Get user email from the console, and check if the user requested // verbosity: $userEmail = $request->getParam('userEmail'); $verbose = $request->getParam('verbose') || $request->getParam('v'); // Reset new password $newPassword = Rand::getString(16); // Fetch the user and change his password, then email him ... /* ... */ if ($verbose) { return \"Done! New password for user $userEmail is '$newPassword'. \" . \"It has also been emailed to him.\\n\"; } return \"Done! $userEmail has received an email with his new password.\\n\"; } } The above creates resetpasswordAction() , which: retrieves the current request; checks if it's really coming from the console (as a precaution); in this example, we do not want our action to be invocable from a web page; pulls console arguments via $request->getParam() ; flags are represented by boolean values, where true means the flag was used, and false means otherwise; performs work based on the arguments; and finally returns a simple string to display to the user via the console.","title":"Handling Console Requests"},{"location":"intro/#adding-console-usage-info","text":"Console applications commonly display usage information when run without arguments. The combination of zend-console and zend-mvc enables this out of the box. Modules can provide usage information, and zend-console will query all loaded modules for console usage information they expose. Let's modify our Application\\Module to provide usage info: namespace Application; use Zend\\ModuleManager\\Feature\\AutoloaderProviderInterface; use Zend\\ModuleManager\\Feature\\ConfigProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; /** * Implementing ConsoleUsageProviderInterface allows the Module to provide * console usage information. */ class Module implements AutoloaderProviderInterface, ConfigProviderInterface, ConsoleUsageProviderInterface { public function getConfig() { /* ... */ } public function getAutoloaderConfig() { /* ... */ } public function getConsoleUsage(Console $console) { return [ // Describe available commands 'user resetpassword [--verbose|-v] EMAIL' => 'Reset password for a user', // Describe expected parameters [ 'EMAIL', 'Email of the user for a password reset' ], [ '--verbose|-v', '(optional) turn on verbose mode' ], ]; } } Each module that implements ConsoleUsageProviderInterface will be queried for console usage info. On route mismatch, all info from all modules will be concatenated, formatted to console width, and shown to the user.","title":"Adding Console Usage Info"},{"location":"prompts/","text":"Console Prompts In addition to the console abstraction layer, zend-console provides numerous convenience classes for interacting with the user in a console environment. This chapter describes available Zend\\Console\\Prompt classes and their usage. All prompts can be instantiated directly, and expose a show() method. use Zend\\Console\\Prompt; $confirm = new Prompt\\Confirm('Are you sure you want to continue?'); $result = $confirm->show(); if ($result) { // the user chose to continue } You can also use prompts statically, via the static prompt() method: use Zend\\Console\\Prompt; $result = Prompt\\Confirm::prompt('Are you sure you want to continue?'); if ($result) { // the user chose to continue } Both of above examples will display something like this: Confirm This prompt is best used for yes / no prompts. Confirm(string $text, string $yesChar = 'y', string $noChar = 'n') : bool Argument Description $text (string) The text to show with the prompt. $yesChar (string) The character that corresponds with the YES choice. (default is y ) $noChar (string) The character that corresponds with the NO choice. (default is n ) Example usage: use Zend\\Console\\Prompt\\Confirm; if ( Confirm::prompt('Is this the correct answer? [y/n]', 'y', 'n')) { $console->write(\"You chose YES\"); } else { $console->write(\"You chose NO\"); } Line This prompt asks for a line of text input. Line( string $text = 'Please enter value', bool $allowEmpty = false, bool $maxLength = 2048 ) : string Argument Description $text (string) The text to show with the prompt. $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $maxLength (integer) Maximum length of the input. Anything above this limit will be truncated. Example usage: use Zend\\Console\\Prompt\\Line; $name = Line::prompt( 'What is your name?', false, 100 ); $console->write(\"Good day to you $name!\"); Char This prompt reads a single keystroke, and optionally validates it against a list of allowed characters. Char( string $text = 'Please hit a key', string $allowedChars = 'abc', bool $ignoreCase = true, bool $allowEmpty = false, bool $echo = true ) : string Argument Description $text (string) The text to show with the prompt. $allowedChars (string) A list of allowed keys that can be pressed. $ignoreCase (boolean) Ignore the case of chars pressed (default is true). $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $echo (boolean) Should the selection be displayed on the screen? Example usage: use Zend\\Console\\Prompt\\Char; $answer = Char::prompt( 'What is the correct answer? [a,b,c,d,e]', 'abcde', true, false, true ); if ($answer == 'b') { $console->write('Correct. This is the right answer.'); } else { $console->write('Wrong! Try again.'); } Select This prompt displays a number of choices, and asks the user to pick one. Select( string $text = 'Please select one option', array $options = [], bool $allowEmpty = false, bool $echo = false ) : string Argument Description $text (string) The text to show with the prompt. $options (array) An associative array with keys strokes (chars) and their displayed values. $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $echo (boolean) Should the selection be displayed on the screen? Example usage: $options = [ 'a' => 'Apples', 'o' => 'Oranges', 'p' => 'Pears', 'b' => 'Bananas', 'n' => 'none of the above...', ]; $answer = Select::prompt( 'Which fruit do you like the best?', $options, false, false ); $console->write(\"You told me that you like \" . $options[$answer]); Password This prompt reads in a string, without echoing that string back to the console; the most common use case is password prompts, which gives it its name. Password( string $promptText = 'Password : ', boolean $echo = true ) : string Argument Description $promptText (string) The text to show with the prompt. $echo (bool) Display * in place of each character typed. Can be skipped. (default is true ) Example usage: use Zend\\Console\\Prompt\\Password; $password = Password::prompt('Enter the secret', true); $console->write(\"Sh!, the password is $password\");","title":"Console Prompts"},{"location":"prompts/#console-prompts","text":"In addition to the console abstraction layer, zend-console provides numerous convenience classes for interacting with the user in a console environment. This chapter describes available Zend\\Console\\Prompt classes and their usage. All prompts can be instantiated directly, and expose a show() method. use Zend\\Console\\Prompt; $confirm = new Prompt\\Confirm('Are you sure you want to continue?'); $result = $confirm->show(); if ($result) { // the user chose to continue } You can also use prompts statically, via the static prompt() method: use Zend\\Console\\Prompt; $result = Prompt\\Confirm::prompt('Are you sure you want to continue?'); if ($result) { // the user chose to continue } Both of above examples will display something like this:","title":"Console Prompts"},{"location":"prompts/#confirm","text":"This prompt is best used for yes / no prompts. Confirm(string $text, string $yesChar = 'y', string $noChar = 'n') : bool Argument Description $text (string) The text to show with the prompt. $yesChar (string) The character that corresponds with the YES choice. (default is y ) $noChar (string) The character that corresponds with the NO choice. (default is n ) Example usage: use Zend\\Console\\Prompt\\Confirm; if ( Confirm::prompt('Is this the correct answer? [y/n]', 'y', 'n')) { $console->write(\"You chose YES\"); } else { $console->write(\"You chose NO\"); }","title":"Confirm"},{"location":"prompts/#line","text":"This prompt asks for a line of text input. Line( string $text = 'Please enter value', bool $allowEmpty = false, bool $maxLength = 2048 ) : string Argument Description $text (string) The text to show with the prompt. $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $maxLength (integer) Maximum length of the input. Anything above this limit will be truncated. Example usage: use Zend\\Console\\Prompt\\Line; $name = Line::prompt( 'What is your name?', false, 100 ); $console->write(\"Good day to you $name!\");","title":"Line"},{"location":"prompts/#char","text":"This prompt reads a single keystroke, and optionally validates it against a list of allowed characters. Char( string $text = 'Please hit a key', string $allowedChars = 'abc', bool $ignoreCase = true, bool $allowEmpty = false, bool $echo = true ) : string Argument Description $text (string) The text to show with the prompt. $allowedChars (string) A list of allowed keys that can be pressed. $ignoreCase (boolean) Ignore the case of chars pressed (default is true). $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $echo (boolean) Should the selection be displayed on the screen? Example usage: use Zend\\Console\\Prompt\\Char; $answer = Char::prompt( 'What is the correct answer? [a,b,c,d,e]', 'abcde', true, false, true ); if ($answer == 'b') { $console->write('Correct. This is the right answer.'); } else { $console->write('Wrong! Try again.'); }","title":"Char"},{"location":"prompts/#select","text":"This prompt displays a number of choices, and asks the user to pick one. Select( string $text = 'Please select one option', array $options = [], bool $allowEmpty = false, bool $echo = false ) : string Argument Description $text (string) The text to show with the prompt. $options (array) An associative array with keys strokes (chars) and their displayed values. $allowEmpty (boolean) Can this prompt be skipped, by pressing [ENTER] ? (default is false) $echo (boolean) Should the selection be displayed on the screen? Example usage: $options = [ 'a' => 'Apples', 'o' => 'Oranges', 'p' => 'Pears', 'b' => 'Bananas', 'n' => 'none of the above...', ]; $answer = Select::prompt( 'Which fruit do you like the best?', $options, false, false ); $console->write(\"You told me that you like \" . $options[$answer]);","title":"Select"},{"location":"prompts/#password","text":"This prompt reads in a string, without echoing that string back to the console; the most common use case is password prompts, which gives it its name. Password( string $promptText = 'Password : ', boolean $echo = true ) : string Argument Description $promptText (string) The text to show with the prompt. $echo (bool) Display * in place of each character typed. Can be skipped. (default is true ) Example usage: use Zend\\Console\\Prompt\\Password; $password = Password::prompt('Enter the secret', true); $console->write(\"Sh!, the password is $password\");","title":"Password"},{"location":"routes/","text":"Routes A powerful feature the zend-console component exposes is routing . Routing reads the command line arguments and matches them to criteria; if the criteria matches, it then returns a list of matched parameters and flags. Handling routing results zend-console exposes routing via the Zend\\Console\\RouteMatcher\\DefaultRouteMatcher class, allowing you to create standalone routable console applications. zend-mvc provides structure around routing results to controllers, which we detail in the MVC Routing chapter . Another option is zf-console , which provides a convenience wrapper around supplying routes and dispatching route handlers. RouteMatcherInterface zend-console defines an interface for routing, Zend\\Console\\RouteMatcher\\RouteMatcherInterface , which defines a single method, match() : namespace Zend\\Console\\RouteMatcher; interface RouteMatcherInterface { /** * Match parameters against route passed to constructor * * @param array $params * @return array|null */ public function match($params); } Applications are expected to retrieve arguments from the console and pass them to the routing implementation as an array; the routing implementation will then return either a null value (meaning failure to match), or an associative array (the values matched). The default Route Matcher zend-console's default routing implementation is Zend\\Console\\RouteMatcher\\DefaultRouteMatcher . Its constructor expects: /** * @param string $route * @param array $constraints * @param array $defaults * @param array $aliases * @param array $filters * @param ValidatorInterface[] $validators * @throws Exception\\InvalidArgumentException */ public function __construct( $route, array $constraints = [], array $defaults = [], array $aliases = [], array $filters = null, array $validators = null ) The arguments are as follows: $route is a string pattern describing the argument list it will match. $constraints is an associative array, with the keys being named arguments, and the values being regular expressions to match against. $defaults are an an associative array of named arguments, with the default value to use if no value was provided; these should only be provided for optional arguments (more on that below). $aliases is an associative array where the key values are the alias names, and the string values are the named argument the alias points to; if an alias is used in the invocation, it will be returned using the named argument instead. As an example, if you provide the alias 'FOO' => 'foo' , and have defined --foo= in the $route , you can invoke it with --FOO=something , and the router will map it to the foo value. $filters is an associative array of named arguments pointing to a Zend\\Filter\\FilterInterface instance (or FilterChain instance); filters are used to normalize the value associated with the argument. $validators is an associative array of named arguments pointing to a Zend\\Validator\\ValidatorInterface instance (or ValidatorChain instance); validators are used to validate values, and provide more options than simply regular expressions (as used with the $constraints ). Single Routes only DefaultRouteMatcher instances define a single console route to match . Most times, you will want to define multiple routes. The zend-mvc integration and zf-console both provide methods for aggregating routes. Routing Strings Routing strings consist of one or more of the following: Literal parameters (e.g. create object (external|internal) ) Literal flags (e.g. --verbose --direct [-d] [-a] ) Positional value parameters (e.g. create <modelName> [<destination>] ) Value flags (e.g. --name=NAME [--method=METHOD] ) Named literal alternative groups (e.g., (all|some|none):filter ) Catch-all parameters (e.g. [...params] ) Literal Parameters Literal parameters are expected to appear on the command line exactly the way they are provided in the route. For example: show users This route will only match for the following command line $ zf show users It expects the mandatory literal parameters show users . It will not match if there are any more parameters, or if either one of the two words is missing. The order of words is also enforced. You can also provide optional literal parameters . As an example: show [all] users The above route will match each of the following: $ zf show users $ zf show all users You can also provide parameter alternatives : show [all|deleted|locked|admin] users The above route will match both with and without the second parameter; if provided, however, it must be one of the words listed. This enables matching any of the following: $ zf show users $ zf show locked users $ zf show admin users # etc. Whitespace is ignored Whitespaces in route definitions are ignored. If you separate your parameters with more spaces, or separate alternatives and pipe characters with spaces, the parser will ignore the whitespace. The above route definition is equivalent to: show [ all | deleted | locked | admin ] users As such, you can use whitespace for readability. Literal Flags Console tools commonly use flags. zend-console allows you to define any number of optional and/or mandatory flags. Flag order is ignored; they can be defined in any order, and the user can provide them in any order. The following is a route with optional long flags : check users [--verbose] [--fast] [--thorough] The above route will match commands like: $ zf check users $ zf check users --fast $ zf check users --verbose --thorough $ zf check users --thorough --fast # etc You can also define one or more mandatory long flags , and group them as an alternative: check users (--suspicious|--expired) [--verbose] [--fast] [--thorough] The above will only match if we provide either the --suspicious or --expired flag: $ zf check users --expired $ zf check users --expired --fast $ zf check users --verbose --thorough --suspicious Short flags are also available, and may be grouped with long flags for convenience: check users [--verbose|-v] [--fast|-f] [--thorough|-t] Now we can use short versions of our flags: $ zf check users -f $ zf check users -v --thorough $ zf check users -t -f -v # etc. Positional Value Parameters Value parameters capture any text-based input, and come in two forms: positional and flags (which we've already discussed). Positional value parameters are expected to appear in an exact position on the command line, and are denoted using angle brackets ( <> ). Consider the following: delete user <userEmail> This route will match the following commands: $ zf delete user john@acme.org $ zf delete user betty@acme.org When matched, the router will return the value under the key we provided in the route definition. If using the DefaultRouteMatcher standalone, this would be: $matches = $route->match($argv); $userEmail = $matches['userEmail']; Under zend-mvc, you will pull the parameter from the request: $userEmail = $this->getRequest()->getParam('userEmail'); You can also define optional positional value parameters by surrounding the parameter with square brackets: delete user [<userEmail>] In this case, the userEmail parameter will not be required for the route to match. If it is not provided, the userEmail parameter will not be present in the matched parameters. You can define any number of positional value parameters: create user <firstName> <lastName> <email> <position> This allows us to capture commands such as the following: $ zf create user Johnny Bravo john@acme.org Entertainer Escaping Command line arguments on all systems must be properly escaped; otherwise they will not be passed to our application correctly. For example, to create a user with two names and a complex position description, we would issue the command like this: $$$$FENCED_CODE_BLOCK_5deeb699e187b0.21195612 Value Flag Parameters Positional value parameters are only matched if they appear in the exact order described in the route. If we do not want to enforce the order of parameters, we can define value flags . Value flags can be defined and matched in any order, and can receive any text-based value. find user [--id=] [--firstName=] [--lastName=] [--email=] [--position=] The above route will match for any of the following routes: $ zf find user $ zf find user --id 29110 $ zf find user --id=29110 $ zf find user --firstName=Johny --lastName=Bravo $ zf find user --lastName Bravo --firstName Johny $ zf find user --position=Executive --firstName=Bob $ zf find user --position \"Head of the Entertainment Department\" # etc. As noted, the order of flags is irrelevant for the parser. Providing Values The parser understands values that are provided after either an equals symbol ( = ) or a single space, but only if the value itself does not contain whitespace. Values containing any whitespace must be properly quoted and appear following a space only ; you cannot use the = sign to assign such values. In the previous example, all value flags are optional. You may also define mandatory value flags by omitting the square brackets: rename user --id= [--firstName=] [--lastName=] In the above example, the --id parameter is required for the route to match. The following commands will work with this route: $ zf rename user --id 123 $ zf rename user --id 123 --firstName Jonathan $ zf rename user --id=123 --lastName=Bravo # etc. Grouping Literal Alternatives In the flags section, we demonstrated grouping alternative flags: check users (--suspicious|--expired) [--verbose] [--fast] [--thorough] This can also be done with literals: show (all|deleted|locked|admin) <group> However, this makes checking for which alternative was used quite difficult: switch (true) { case (isset($params['all'])): // all members break; case (isset($params['deleted'])): // deleted members break; /* etc. */ } To simplify this, you can assign a name to the grouped alternatives . Do this with the verbiage :groupname following the group: show (all|deleted|locked|admin):filter <group> The above names the group \"filter\". When a group is provided a name, you can then retrieve the group name parameter, which will be set to the alternative used: switch ($params['filter']) { case 'all': // all members break; case 'deleted': // deleted members break; /* etc. */ } Catch-all Parameters Since 2.7.0 When a route may receive a variable number of parameters (for example, to implement a feature like echo, or to process an arbitrary list of files), you can use a catch-all parameter to collect all parameters that are not matched by another part of the route. These collected values can be accessed as a single parameter (whose name is defined in the route) containing an array. When used, the catch-all parameter must come after all positional value parameters. You can only use one catch-all parameter per route. Example: say [loudly|softly]:volume [...words] If the user entered the command line say loudly I am here , the 'volume' parameter would contain 'loudly' and the 'words' parameter would contain ['I', 'am', 'here'] . Console Routes Cheat-Sheet Param type Example route definition Explanation Literal params Literal foo bar \"foo\" followed by \"bar\" Literal alternative foo (bar|baz) \"foo\" followed by \"bar\" or \"baz\" Literal, optional foo [bar] \"foo\", optional \"bar\" Literal, optional alternative foo [bar|baz] \"foo\", optional \"bar\" or \"baz\" Flags Flag long foo --bar \"foo\" as first parameter, \"--bar\" flag before or after Flag long, optional foo [--bar] \"foo\" as first parameter, optional \"--bar\" flag before or after Flag long, optional, alternative foo [--bar|--baz] \"foo\" as first parameter, optional \"--bar\" or \"--baz\", before or after Flag short foo -b \"foo\" as first parameter, \"-b\" flag before or after Flag short, optional foo [-b] \"foo\" as first parameter, optional \"-b\" flag before or after Flag short, optional, alternative foo [-b|-z] \"foo\" as first parameter, optional \"-b\" or \"-z\", before or after Flag long/short alternative foo [--bar|-b] \"foo\" as first parameter, optional \"--bar\" or \"-b\" before or after Value parameters Value positional param foo <bar> \"foo\" followed by any text (stored as \"bar\" param) Value positional param, optional foo [<bar>] \"foo\", optionally followed by any text (stored as \"bar\" param) Value Flag foo --bar= \"foo\" as first parameter, \"--bar\" with a value, before or after Value Flag, optional foo [--bar=] \"foo\" as first parameter, optionally \"--bar\" with a value, before or after Parameter groups Literal params group foo (bar|baz):myParam \"foo\" followed by \"bar\" or \"baz\" (stored as \"myParam\" param) Literal optional params group foo [bar|baz]:myParam \"foo\" followed by optional \"bar\" or \"baz\" (stored as \"myParam\" param) Long flags group foo (--bar|--baz):myParam \"foo\", \"bar\" or \"baz\" flag before or after (stored as \"myParam\" param) Long optional flags group foo [--bar|--baz]:myParam \"foo\", optional \"bar\" or \"baz\" flag before or after (as \"myParam\" param) Short flags group foo (-b|-z):myParam \"foo\", \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param) Short optional flags group foo [-b|-z]:myParam \"foo\", optional \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param) Catch-all parameters Simple catch-all foo [...bar] \"foo\" followed by any number of params, stored as array in \"bar\" param Literal alternative w/ catch-all foo (bar|baz) [...xyzzy] \"foo\" followed by \"bar\" or \"baz\", with extra input stored as \"xyzzy\" param Value param w/ catch-all foo <bar> [...baz] \"foo\", with first parameter stored as \"bar\" and remainder stored as \"baz\"","title":"Routes"},{"location":"routes/#routes","text":"A powerful feature the zend-console component exposes is routing . Routing reads the command line arguments and matches them to criteria; if the criteria matches, it then returns a list of matched parameters and flags.","title":"Routes"},{"location":"routes/#routematcherinterface","text":"zend-console defines an interface for routing, Zend\\Console\\RouteMatcher\\RouteMatcherInterface , which defines a single method, match() : namespace Zend\\Console\\RouteMatcher; interface RouteMatcherInterface { /** * Match parameters against route passed to constructor * * @param array $params * @return array|null */ public function match($params); } Applications are expected to retrieve arguments from the console and pass them to the routing implementation as an array; the routing implementation will then return either a null value (meaning failure to match), or an associative array (the values matched).","title":"RouteMatcherInterface"},{"location":"routes/#the-default-route-matcher","text":"zend-console's default routing implementation is Zend\\Console\\RouteMatcher\\DefaultRouteMatcher . Its constructor expects: /** * @param string $route * @param array $constraints * @param array $defaults * @param array $aliases * @param array $filters * @param ValidatorInterface[] $validators * @throws Exception\\InvalidArgumentException */ public function __construct( $route, array $constraints = [], array $defaults = [], array $aliases = [], array $filters = null, array $validators = null ) The arguments are as follows: $route is a string pattern describing the argument list it will match. $constraints is an associative array, with the keys being named arguments, and the values being regular expressions to match against. $defaults are an an associative array of named arguments, with the default value to use if no value was provided; these should only be provided for optional arguments (more on that below). $aliases is an associative array where the key values are the alias names, and the string values are the named argument the alias points to; if an alias is used in the invocation, it will be returned using the named argument instead. As an example, if you provide the alias 'FOO' => 'foo' , and have defined --foo= in the $route , you can invoke it with --FOO=something , and the router will map it to the foo value. $filters is an associative array of named arguments pointing to a Zend\\Filter\\FilterInterface instance (or FilterChain instance); filters are used to normalize the value associated with the argument. $validators is an associative array of named arguments pointing to a Zend\\Validator\\ValidatorInterface instance (or ValidatorChain instance); validators are used to validate values, and provide more options than simply regular expressions (as used with the $constraints ).","title":"The default Route Matcher"},{"location":"routes/#routing-strings","text":"Routing strings consist of one or more of the following: Literal parameters (e.g. create object (external|internal) ) Literal flags (e.g. --verbose --direct [-d] [-a] ) Positional value parameters (e.g. create <modelName> [<destination>] ) Value flags (e.g. --name=NAME [--method=METHOD] ) Named literal alternative groups (e.g., (all|some|none):filter ) Catch-all parameters (e.g. [...params] )","title":"Routing Strings"},{"location":"routes/#console-routes-cheat-sheet","text":"Param type Example route definition Explanation Literal params Literal foo bar \"foo\" followed by \"bar\" Literal alternative foo (bar|baz) \"foo\" followed by \"bar\" or \"baz\" Literal, optional foo [bar] \"foo\", optional \"bar\" Literal, optional alternative foo [bar|baz] \"foo\", optional \"bar\" or \"baz\" Flags Flag long foo --bar \"foo\" as first parameter, \"--bar\" flag before or after Flag long, optional foo [--bar] \"foo\" as first parameter, optional \"--bar\" flag before or after Flag long, optional, alternative foo [--bar|--baz] \"foo\" as first parameter, optional \"--bar\" or \"--baz\", before or after Flag short foo -b \"foo\" as first parameter, \"-b\" flag before or after Flag short, optional foo [-b] \"foo\" as first parameter, optional \"-b\" flag before or after Flag short, optional, alternative foo [-b|-z] \"foo\" as first parameter, optional \"-b\" or \"-z\", before or after Flag long/short alternative foo [--bar|-b] \"foo\" as first parameter, optional \"--bar\" or \"-b\" before or after Value parameters Value positional param foo <bar> \"foo\" followed by any text (stored as \"bar\" param) Value positional param, optional foo [<bar>] \"foo\", optionally followed by any text (stored as \"bar\" param) Value Flag foo --bar= \"foo\" as first parameter, \"--bar\" with a value, before or after Value Flag, optional foo [--bar=] \"foo\" as first parameter, optionally \"--bar\" with a value, before or after Parameter groups Literal params group foo (bar|baz):myParam \"foo\" followed by \"bar\" or \"baz\" (stored as \"myParam\" param) Literal optional params group foo [bar|baz]:myParam \"foo\" followed by optional \"bar\" or \"baz\" (stored as \"myParam\" param) Long flags group foo (--bar|--baz):myParam \"foo\", \"bar\" or \"baz\" flag before or after (stored as \"myParam\" param) Long optional flags group foo [--bar|--baz]:myParam \"foo\", optional \"bar\" or \"baz\" flag before or after (as \"myParam\" param) Short flags group foo (-b|-z):myParam \"foo\", \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param) Short optional flags group foo [-b|-z]:myParam \"foo\", optional \"-b\" or \"-z\" flag before or after (stored as \"myParam\" param) Catch-all parameters Simple catch-all foo [...bar] \"foo\" followed by any number of params, stored as array in \"bar\" param Literal alternative w/ catch-all foo (bar|baz) [...xyzzy] \"foo\" followed by \"bar\" or \"baz\", with extra input stored as \"xyzzy\" param Value param w/ catch-all foo <bar> [...baz] \"foo\", with first parameter stored as \"bar\" and remainder stored as \"baz\"","title":"Console Routes Cheat-Sheet"},{"location":"getopt/configuration/","text":"Configuration Adding Option Rules You can add more option rules in addition to those you specified in the Zend\\Console\\Getopt constructor via the addRules() method. The argument to addRules() is the same as the first argument to the class constructor: it is either a string in the format of the short syntax options specification, or else an associative array in the format of a long syntax options specification. See Declaring Getopt Rules for details on the syntax for specifying options. Using addRules() $opts = new Zend\\Console\\Getopt('abp:'); $opts->addRules([ 'verbose|v' => 'Print verbose output', ]); The example above shows adding the --verbose option with an alias of -v to a set of options defined in the call to the constructor. Notice that you can mix short format options and long format options in the same instance of Zend\\Console\\Getopt . Adding Help Messages In addition to specifying the help strings when declaring option rules in the long format, you can associate help strings with option rules using the setHelp() method. The argument to the setHelp() method is an associative array, in which the key is a flag, and the value is a corresponding help string. Using setHelp() $opts = new Zend\\Console\\Getopt('abp:'); $opts->setHelp([ 'a' => 'apple option, with no parameter', 'b' => 'banana option, with required integer parameter', 'p' => 'pear option, with optional string parameter', ]); If you declared options with aliases, you can use any of the aliases as the key of the associative array. The setHelp() method is the only way to define help strings if you declared the options using the short syntax. Adding Option Aliases You can declare aliases for options using the setAliases() method. The argument is an associative array, where keys are flag strings declared previously, and values are new aliases for the flags. These aliases are merged with any existing aliases. In other words, aliases you declared earlier are still in effect. An alias may be declared only once. If you try to redefine an alias, a Zend\\Console\\Getopt\\Exception is thrown. Using setAliases() $opts = new Zend\\Console\\Getopt('abp:'); $opts->setAliases([ 'a' => 'apple', 'a' => 'apfel', 'p' => 'pear', ]); In the example above, after declaring these aliases, -a , --apple and --apfel are aliases for each other. Also -p and --pear are aliases for each other. The setAliases() method is the only way to define aliases if you declared the options using the short syntax. Adding Argument Lists By default, Zend\\Console\\Getopt uses $_SERVER['argv'] for the array of command-line arguments to parse. You can alternatively specify the array of arguments as the second constructor argument. Finally, you can append more arguments to those already used using the addArguments() method, or you can replace the current array of arguments using the setArguments() method. In both cases, the parameter to these methods is a simple array of strings. The former method appends the array to the current arguments, and the latter method substitutes the array for the current arguments. Using addArguments() and setArguments() // By default, the constructor uses $_SERVER['argv'] $opts = new Zend\\Console\\Getopt('abp:'); // Append an array to the existing arguments $opts->addArguments(['-a', '-p', 'p_parameter', 'non_option_arg']); // Substitute a new array for the existing arguments $opts->setArguments(['-a', '-p', 'p_parameter', 'non_option_arg']); Adding Configuration The third parameter to the Zend\\Console\\Getopt constructor is an array of configuration options that affect the behavior of the object instance returned. You can also specify configuration options using the setOptions() method, or you can set an individual option using the setOption() method. Clarifying the Term \"option\" The term \"option\" is used for configuration of the Zend\\Console\\Getopt class to match terminology used elsewhere in Zend Framework. These are not the same things as the command-line options that are parsed by the Zend\\Console\\Getopt class. The currently supported options have constant definitions in the class. The options, along with their constant identifiers and literal values (in parentheses) are listed below: Zend\\Console\\Getopt::CONFIG_DASHDASH (\"dashDash\"), if TRUE , enables the special flag -- to signify the end of flags. Command-line arguments following the double-dash signifier are not interpreted as options, even if the arguments start with a dash. This configuration option is TRUE by default. Zend\\Console\\Getopt::CONFIG_IGNORECASE (\"ignoreCase\"), if TRUE , makes flags aliases of each other if they differ only in their case. That is, -a and -A will be considered to be synonymous flags. This configuration option is FALSE by default. Zend\\Console\\Getopt::CONFIG_RULEMODE (\"ruleMode\") may have values Zend\\Console\\Getopt::MODE_ZEND (\"zend\") and Zend\\Console\\Getopt::MODE_GNU (\"gnu\"). It should not be necessary to use this option unless you extend the class with additional syntax forms. The two modes supported in the base Zend\\Console\\Getopt class are unambiguous. If the specifier is a string, the class assumes MODE_GNU , otherwise it assumes MODE_ZEND . But if you extend the class and add more syntax forms, you may need to specify the mode using this option. More configuration options may be added as future enhancements of this class. Using setOption() The two arguments to the setOption() method are a configuration option name and an option value. $opts = new Zend\\Console\\Getopt('abp:'); $opts->setOption('ignoreCase', true); Using setOptions() The argument to the setOptions() method is an associative array. The keys of this array are the configuration option names, and the values are configuration values. This is also the array format used in the class constructor. The configuration values you specify are merged with the current configuration; you don't have to list all options. $opts = new Zend\\Console\\Getopt('abp:'); $opts->setOptions([ 'ignoreCase' => true, 'dashDash' => false, ]);","title":"Configuration"},{"location":"getopt/configuration/#configuration","text":"","title":"Configuration"},{"location":"getopt/configuration/#adding-option-rules","text":"You can add more option rules in addition to those you specified in the Zend\\Console\\Getopt constructor via the addRules() method. The argument to addRules() is the same as the first argument to the class constructor: it is either a string in the format of the short syntax options specification, or else an associative array in the format of a long syntax options specification. See Declaring Getopt Rules for details on the syntax for specifying options.","title":"Adding Option Rules"},{"location":"getopt/configuration/#adding-help-messages","text":"In addition to specifying the help strings when declaring option rules in the long format, you can associate help strings with option rules using the setHelp() method. The argument to the setHelp() method is an associative array, in which the key is a flag, and the value is a corresponding help string.","title":"Adding Help Messages"},{"location":"getopt/configuration/#adding-option-aliases","text":"You can declare aliases for options using the setAliases() method. The argument is an associative array, where keys are flag strings declared previously, and values are new aliases for the flags. These aliases are merged with any existing aliases. In other words, aliases you declared earlier are still in effect. An alias may be declared only once. If you try to redefine an alias, a Zend\\Console\\Getopt\\Exception is thrown.","title":"Adding Option Aliases"},{"location":"getopt/configuration/#adding-argument-lists","text":"By default, Zend\\Console\\Getopt uses $_SERVER['argv'] for the array of command-line arguments to parse. You can alternatively specify the array of arguments as the second constructor argument. Finally, you can append more arguments to those already used using the addArguments() method, or you can replace the current array of arguments using the setArguments() method. In both cases, the parameter to these methods is a simple array of strings. The former method appends the array to the current arguments, and the latter method substitutes the array for the current arguments.","title":"Adding Argument Lists"},{"location":"getopt/configuration/#adding-configuration","text":"The third parameter to the Zend\\Console\\Getopt constructor is an array of configuration options that affect the behavior of the object instance returned. You can also specify configuration options using the setOptions() method, or you can set an individual option using the setOption() method.","title":"Adding Configuration"},{"location":"getopt/fetching/","text":"Fetching Options and Arguments After you have declared the options that the Zend\\Console\\Getopt object should recognize, and supplied arguments from the command-line or an array, you can query the object to find out which options were specified by a user in a given command-line invocation of your program. The class implements magic methods so you can query for options by name. The parsing of the data is deferred until the first query you make against the Zend\\Console\\Getopt object to find out if an option was given. This allows you to use several method calls to configure the options, arguments, help strings, and configuration options before parsing takes place. Handling Getopt Exceptions If the user gave any invalid options on the command-line, the parsing function throws a Zend\\Console\\Exception\\RuntimeException . You should catch this exception in your application code. You can use the parse() method to force the object to parse the arguments. This is useful because you can invoke parse() in a try block; if it passes, you can be sure that the parsing won't throw an exception again. The exception thrown has a custom method getUsageMessage() which returns as a string the formatted set of usage messages for all declared options. Catching Getopt Exceptions try { $opts = new Zend\\Console\\Getopt('abp:'); $opts->parse(); } catch (Zend\\Console\\Exception\\RuntimeException $e) { echo $e->getUsageMessage(); exit; } Cases where parsing throws an exception include: Option given is not recognized. Option requires a parameter but none was given. Option parameter is of the wrong type; e.g. a non-numeric string when an integer was required. Fetching Options by Name You can use the getOption() method to query the value of an option. If the option had a parameter, this method returns the value of the parameter. If the option had no parameter but the user did specify it on the command-line, the method returns TRUE . Otherwise the method returns NULL . Using getOption() $opts = new Zend\\Console\\Getopt('abp:'); $b = $opts->getOption('b'); $p_parameter = $opts->getOption('p'); Alternatively, you can use the property overloading via the magic __isset() and __get() methods, allowing you to test for and retrieve values as if they were property names. Using property Overloading $opts = new Zend\\Console\\Getopt('abp:'); if (isset($opts->b)) { echo \"I got the b option.\\n\"; } $p_parameter = $opts->p; // null if not set Using Aliases If your options are declared with aliases, you may use any of the aliases for an option when retrieving its value. Reporting Options There are several methods to report the full set of options given by the user on the current command-line. As a string: use the toString() method. The options are returned as a space-separated string of flag=value pairs. The value of an option that does not have a parameter is the literal string \" TRUE \". As an array: use the toArray() method. The options are returned in a simple integer-indexed array of strings, the flag strings followed by parameter strings, if any. As a string containing JSON data: use the toJson() method. As a string containing XML data: use the toXml() method. In all of the above dumping methods, the flag strings are the first strings in the corresponding list of aliases. For example, if the option aliases were declared like verbose|v , then the first string, verbose , is used as the canonical name of the option. The name of the option flag does not include any preceding dashes. Fetching Non-option Arguments After option arguments and their parameters have been parsed from the command-line, there may be additional arguments remaining. You can query these arguments using the getRemainingArgs() method. This method returns an array of the strings that were not part of any options. Using getRemainingArgs() $opts = new Zend\\Console\\Getopt('abp:'); $opts->setArguments(['-p', 'p_parameter', 'filename']); $args = $opts->getRemainingArgs(); // returns ['filename'] Zend\\Console\\Getopt supports the GNU convention that an argument consisting of a double-dash signifies the end of options. Any arguments following this signifier must be treated as non-option arguments. This is useful if you might have a non-option argument that begins with a dash. For example: rm -- -filename-with-dash .","title":"Fetching Options and Arguments"},{"location":"getopt/fetching/#fetching-options-and-arguments","text":"After you have declared the options that the Zend\\Console\\Getopt object should recognize, and supplied arguments from the command-line or an array, you can query the object to find out which options were specified by a user in a given command-line invocation of your program. The class implements magic methods so you can query for options by name. The parsing of the data is deferred until the first query you make against the Zend\\Console\\Getopt object to find out if an option was given. This allows you to use several method calls to configure the options, arguments, help strings, and configuration options before parsing takes place.","title":"Fetching Options and Arguments"},{"location":"getopt/fetching/#handling-getopt-exceptions","text":"If the user gave any invalid options on the command-line, the parsing function throws a Zend\\Console\\Exception\\RuntimeException . You should catch this exception in your application code. You can use the parse() method to force the object to parse the arguments. This is useful because you can invoke parse() in a try block; if it passes, you can be sure that the parsing won't throw an exception again. The exception thrown has a custom method getUsageMessage() which returns as a string the formatted set of usage messages for all declared options.","title":"Handling Getopt Exceptions"},{"location":"getopt/fetching/#fetching-options-by-name","text":"You can use the getOption() method to query the value of an option. If the option had a parameter, this method returns the value of the parameter. If the option had no parameter but the user did specify it on the command-line, the method returns TRUE . Otherwise the method returns NULL .","title":"Fetching Options by Name"},{"location":"getopt/fetching/#reporting-options","text":"There are several methods to report the full set of options given by the user on the current command-line. As a string: use the toString() method. The options are returned as a space-separated string of flag=value pairs. The value of an option that does not have a parameter is the literal string \" TRUE \". As an array: use the toArray() method. The options are returned in a simple integer-indexed array of strings, the flag strings followed by parameter strings, if any. As a string containing JSON data: use the toJson() method. As a string containing XML data: use the toXml() method. In all of the above dumping methods, the flag strings are the first strings in the corresponding list of aliases. For example, if the option aliases were declared like verbose|v , then the first string, verbose , is used as the canonical name of the option. The name of the option flag does not include any preceding dashes.","title":"Reporting Options"},{"location":"getopt/fetching/#fetching-non-option-arguments","text":"After option arguments and their parameters have been parsed from the command-line, there may be additional arguments remaining. You can query these arguments using the getRemainingArgs() method. This method returns an array of the strings that were not part of any options.","title":"Fetching Non-option Arguments"},{"location":"getopt/intro/","text":"Introduction The Zend\\Console\\Getopt class helps command-line applications to parse their options and arguments. Users may specify command-line arguments when they execute your application. These arguments have meaning to the application, to change the behavior in some way, or choose resources, or specify parameters. Many options have developed customary meaning, for example --verbose enables extra output from many applications. Other options may have a meaning that is different for each application. For example, -c enables different features in grep , ls , and tar . Below are a few definitions of terms. Common usage of the terms varies, but this documentation will use the definitions below. \"argument\": a string that occurs on the command-line following the name of the command. Arguments may be options or else may appear without an option, to name resources on which the command operates. \"option\": an argument that signifies that the command should change its default behavior in some way. \"flag\": the first part of an option, identifies the purpose of the option. A flag is preceded conventionally by one or two dashes ( - or -- ). A single dash precedes a single-character flag or a cluster of single-character flags. A double-dash precedes a multi-character flag. Long flags cannot be clustered. \"parameter\": the secondary part of an option; a data value that may accompany a flag, if it is applicable to the given option. For example, many commands accept a --verbose option, but typically this option has no parameter. However, an option like --user almost always requires a following parameter. A parameter may be given as a separate argument following a flag argument, or as part of the same argument string, separated from the flag by an equals symbol ( = ). The latter form is supported only by long flags. For example, -u username , --user username , and --user=username are forms supported by Zend\\Console\\Getopt . - \"cluster\": multiple single-character flags combined in a single string argument and preceded by a single dash. For example, \" ls -1str \" uses a cluster of four short flags. This command is equivalent to \" ls -1 -s -t -r \". Only single-character flags can be clustered. You cannot make a cluster of long flags. For example, in mysql --user=root mydatabase , mysql is a command , --user=root is an option ( --user is a flag and root is a parameter to the option), and mydatabase is an argument (but not an option by our definition). Zend\\Console\\Getopt provides an interface to declare which flags are valid for your application, output an error and usage message if they invalid flags are specified, and report to your application which flags the user specified. Getopt is not an Application Framework Zend\\Console\\Getopt does not interpret the meaning of flags and parameters, nor does this class implement application workflow or invoke application code. You must implement those actions in your own application code. You can use the Zend\\Console\\Getopt class to parse the command-line and provide object-oriented methods for querying which options were given by a user, but code to use this information to invoke parts of your application should be in another PHP class. The following sections describe usage of Zend\\Console\\Getopt .","title":"Introduction"},{"location":"getopt/intro/#introduction","text":"The Zend\\Console\\Getopt class helps command-line applications to parse their options and arguments. Users may specify command-line arguments when they execute your application. These arguments have meaning to the application, to change the behavior in some way, or choose resources, or specify parameters. Many options have developed customary meaning, for example --verbose enables extra output from many applications. Other options may have a meaning that is different for each application. For example, -c enables different features in grep , ls , and tar . Below are a few definitions of terms. Common usage of the terms varies, but this documentation will use the definitions below. \"argument\": a string that occurs on the command-line following the name of the command. Arguments may be options or else may appear without an option, to name resources on which the command operates. \"option\": an argument that signifies that the command should change its default behavior in some way. \"flag\": the first part of an option, identifies the purpose of the option. A flag is preceded conventionally by one or two dashes ( - or -- ). A single dash precedes a single-character flag or a cluster of single-character flags. A double-dash precedes a multi-character flag. Long flags cannot be clustered. \"parameter\": the secondary part of an option; a data value that may accompany a flag, if it is applicable to the given option. For example, many commands accept a --verbose option, but typically this option has no parameter. However, an option like --user almost always requires a following parameter. A parameter may be given as a separate argument following a flag argument, or as part of the same argument string, separated from the flag by an equals symbol ( = ). The latter form is supported only by long flags. For example, -u username , --user username , and --user=username are forms supported by Zend\\Console\\Getopt . - \"cluster\": multiple single-character flags combined in a single string argument and preceded by a single dash. For example, \" ls -1str \" uses a cluster of four short flags. This command is equivalent to \" ls -1 -s -t -r \". Only single-character flags can be clustered. You cannot make a cluster of long flags. For example, in mysql --user=root mydatabase , mysql is a command , --user=root is an option ( --user is a flag and root is a parameter to the option), and mydatabase is an argument (but not an option by our definition). Zend\\Console\\Getopt provides an interface to declare which flags are valid for your application, output an error and usage message if they invalid flags are specified, and report to your application which flags the user specified.","title":"Introduction"},{"location":"getopt/intro/#getopt-is-not-an-application-framework","text":"Zend\\Console\\Getopt does not interpret the meaning of flags and parameters, nor does this class implement application workflow or invoke application code. You must implement those actions in your own application code. You can use the Zend\\Console\\Getopt class to parse the command-line and provide object-oriented methods for querying which options were given by a user, but code to use this information to invoke parts of your application should be in another PHP class. The following sections describe usage of Zend\\Console\\Getopt .","title":"Getopt is not an Application Framework"},{"location":"getopt/rules/","text":"Declaring Rules The constructor for the Zend\\Console\\Getopt class takes from one to three arguments. The first argument declares which options are supported by your application. This class supports alternative syntax forms for declaring the options. See the sections below for the format and usage of these syntax forms. The constructor takes two more arguments, both of which are optional. The second argument may contain the command-line arguments. This defaults to $_SERVER['argv'] . The third argument of the constructor may contain any configuration options required to customize the behavior of Zend\\Console\\Getopt . See Adding Configuration for a reference on the options available. Declaring Options with the Short Syntax Zend\\Console\\Getopt supports a compact syntax similar to that used by GNU Getopt . This syntax supports only single-character flags. In a single string, you type each of the letters that correspond to flags supported by your application. A letter followed by a colon character ( : ) indicates a flag that requires a parameter. Using the Short Syntax $opts = new Zend\\Console\\Getopt('abp:'); The example above shows using Zend\\Console\\Getopt to declare that options may be given as -a , -b , or -p . The latter flag requires a parameter. The short syntax is limited to flags of a single character. Aliases, parameter types, and help strings are not supported in the short syntax. Declaring Options with the Long Syntax A different syntax with more features is also available. This syntax allows you to specify aliases for flags, types of option parameters, and also help strings to describe usage to the user. Instead of the single string used in the short syntax to declare the options, the long syntax uses an associative array as the first argument to the constructor. The key of each element of the associative array is a string with a format that names the flag, with any aliases, separated by the pipe symbol ( | ). Following this series of flag aliases, if the option requires a parameter, is an equals symbol ( = ) with a letter that stands for the type of the parameter: =s for a string parameter =w for a word parameter (a string containing no whitespace) =i for an integer parameter If the parameter is optional, use a dash ( - ) instead of the equals symbol. The value of each element in the associative array is a help string to describe to a user how to use your program. Using the Long Syntax $opts = new Zend\\Console\\Getopt( array( 'apple|a' => 'apple option, with no parameter', 'banana|b=i' => 'banana option, with required integer parameter', 'pear|p-s' => 'pear option, with optional string parameter' ) ); In the example declaration above, there are three options. --apple and -a are aliases for each other, and the option takes no parameter. --banana and -b are aliases for each other, and the option takes a mandatory integer parameter. Finally, --pear and -p are aliases for each other, and the option may take an optional string parameter.","title":"Declaring Rules"},{"location":"getopt/rules/#declaring-rules","text":"The constructor for the Zend\\Console\\Getopt class takes from one to three arguments. The first argument declares which options are supported by your application. This class supports alternative syntax forms for declaring the options. See the sections below for the format and usage of these syntax forms. The constructor takes two more arguments, both of which are optional. The second argument may contain the command-line arguments. This defaults to $_SERVER['argv'] . The third argument of the constructor may contain any configuration options required to customize the behavior of Zend\\Console\\Getopt . See Adding Configuration for a reference on the options available.","title":"Declaring Rules"},{"location":"getopt/rules/#declaring-options-with-the-short-syntax","text":"Zend\\Console\\Getopt supports a compact syntax similar to that used by GNU Getopt . This syntax supports only single-character flags. In a single string, you type each of the letters that correspond to flags supported by your application. A letter followed by a colon character ( : ) indicates a flag that requires a parameter.","title":"Declaring Options with the Short Syntax"},{"location":"getopt/rules/#declaring-options-with-the-long-syntax","text":"A different syntax with more features is also available. This syntax allows you to specify aliases for flags, types of option parameters, and also help strings to describe usage to the user. Instead of the single string used in the short syntax to declare the options, the long syntax uses an associative array as the first argument to the constructor. The key of each element of the associative array is a string with a format that names the flag, with any aliases, separated by the pipe symbol ( | ). Following this series of flag aliases, if the option requires a parameter, is an equals symbol ( = ) with a letter that stands for the type of the parameter: =s for a string parameter =w for a word parameter (a string containing no whitespace) =i for an integer parameter If the parameter is optional, use a dash ( - ) instead of the equals symbol. The value of each element in the associative array is a help string to describe to a user how to use your program.","title":"Declaring Options with the Long Syntax"},{"location":"mvc/controllers/","text":"Console-Aware Controllers When using the zend-mvc integration with zend-console, a matched route results in dispatch of an action controller. In this chapter we will learn how ZF2 Controllers can interact with and return output to console window. Handling Console Requests Console requests are very similar to HTTP requests. In fact, they implement a common interface and are created at the same time in the MVC workflow. Console routes match against command line arguments and provide a defaults array, which holds the controller and action keys. These correspond with controller aliases in the ServiceManager , and method names in the controller class. This is analogous to the way HTTP requests are handled under zend-mvc. In this example we'll use the following route: // in file module/Application/config/module.config.php: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ 'list-users' => [ 'options' => [ 'route' => 'show [all|disabled|deleted]:mode users [--verbose|-v]', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'show-users', ], ], ], ], ], ], /* ... */ ); This route will match commands such as: $ php public/index.php show users $ php public/index.php show all users $ php public/index.php show disabled users This route maps to the method Application\\Controller\\IndexController::showUsersAction() . Let's add it that method to our controller. <?php namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { public function indexAction() { return new ViewModel(); // display standard index page } public function showUsersAction() { $request = $this->getRequest(); $users = $this->getServiceLocator()->get('users'); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = array(); switch ($mode) { case 'disabled': $users = $users->fetchDisabledUsers(); break; case 'deleted': $users = $users->fetchDeletedUsers(); break; case 'all': default: $users = $users->fetchAllUsers(); break; } } } We fetch the console request, read parameters, and load users from our (theoretical) users service. In order to make this method functional, we'll have to display the result in the console window. Sending Output to the Console The simplest way for our controller to display data in the console window is to return a string. Let's modify our example to output a list of users: public function showUsersAction() { $request = $this->getRequest(); $users = $this->getServiceLocator()->get('users'); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = array(); switch ($mode) { case 'disabled': $users = $users->fetchDisabledUsers(); break; case 'deleted': $users = $users->fetchDeletedUsers(); break; case 'all': default: $users = $users->fetchAllUsers(); break; } if (count($users) === 0) { // Show an error message in the console return \"There are no users in the database\\n\"; } $result = ''; foreach ($users as $user) { $result .= $user->name . ' ' . $user->email . \"\\n\"; } return $result; // show it in the console } In the second conditional, we are checking if the users service found any users; if not, we return an error message to display immediately, terminating the application. If any users are found, we loop through each to prepare a listing, which we then return from the action for display in the console. Are we in a Console? Sometimes we might need to check if our method is being called from a console or from a web request. This is useful to block certain methods from running in the console or to change their behavior based on that context. Here is an example of how to check if we are dealing with a console request: namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); // Make sure that we are running in a console and the user has not tricked our // application into running this action from a public web server. if (! $request instanceof ConsoleRequest) { throw new RuntimeException('You can only use this action from a console!'); } /* ... */ } } Use Routing to protect Methods You do not need to secure all your controllers and methods from console requests. Controller actions will only be invoked when at least one console route matches it. HTTP and Console routes are separated and defined in different places in module (and application) configuration. There is no way to invoke a console action unless there is at least one route pointing to it. Similarly, there is no way for an HTTP action to be invoked unless there is at least one HTTP route that points to it. The example below shows how a single controller method can handle both Console and HTTP requests : namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use Zend\\Http\\Request as HttpRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); $users = array(); /* ... fetch users from database ... */ if ($request instanceof HttpRequest) { // display a web page with users list return new ViewModel($result); } if ($request instanceof ConsoleRequest) { // ... prepare console output and return it ... return $result; } throw new RuntimeException('Cannot handle request of type ' . get_class($request)); } } AbstractConsoleController One way to ensure you always receive a console request instance is to extend Zend\\Mvc\\Controller\\AbstractConsoleController . This controller instance also exposes a new method, getConsole() , providing you access to the console adapter, allowing you to use prompts, send output (including colorized output), and more. Reading Values from Console Parameters There are several types of parameters recognized by the Console component, all of which are described in the console routing chapter . Here, we'll focus on how to retrieve values from distinct parameters and flags. Positional Parameters After a route matches, we can access both literal parameters and value parameters via the $request instance, using the getParam() method. Assuming we have the following route: 'show-users' => [ 'options' => [ 'route' => 'show (all|deleted|locked|admin) [<groupName>]' 'defaults' => [ 'controller' => 'Application\\Controller\\Users', 'action' => 'showusers', ], ], ], If this route matches, our action can now query parameters in the following way: // an action inside Application\\Controller\\UsersController: public function showUsersAction() { $request = $this->getRequest(); // We can access named value parameters directly by their name: $showUsersFromGroup = $request->getParam('groupName'); // Literal parameters can be checked with isset() against their exact spelling if (isset($request->getParam('all'))) { // show all users } elseif (isset($request->getParam('deleted'))) { // show deleted users } /* ... */ } In case of parameter alternatives, it is a good idea to assign a name to the group , which simplifies the branching in our action controllers. We can do this with the following syntax: // inside of config.console.router.routes: 'show-users' => array( 'options' => array( 'route' => 'show (all|deleted|locked|admin):userTypeFilter [<groupName>]' 'defaults' => array( 'controller' => 'Application\\Controller\\Users', 'action' => 'showusers' ) ) ) Now we can use a the group name userTypeFilter to check which option has been selected by the user: public function showUsersAction() { $request = $this->getRequest(); // We can access named value parameters directly by their name: $showUsersFromGroup = $request->getParam('groupName'); // The selected option from second parameter is now stored under 'userTypeFilter' $userTypeFilter = $request->getParam('userTypeFilter'); switch ($userTypeFilter) { case 'all': // all users case 'deleted': // deleted users case 'locked' // ... // ... } } Flags Flags are directly accessible by name. Value-capturing flags will contain string values, as provided by the user. Non-value flags will be equal to true , or null if not present. Given the following route: 'find-user' => [ 'options' => [ 'route' => 'find user [--fast] [--verbose] [--id=] [--firstName=] [--lastName=] [--email=] ', 'defaults' => [ 'controller' => 'Application\\Controller\\Users', 'action' => 'find', ], ], ], We can retrieve values in the following fashion: public function findAction() { $request = $this->getRequest(); // We can retrieve values from value flags using their name $searchId = $request->getParam('id', null); // default null $searchFirstName = $request->getParam('firstName', null); $searchLastName = $request->getParam('lastName', null); $searchEmail = $request->getParam('email', null); // Standard flags that have been matched will be equal to TRUE $isFast = (bool) $request->getParam('fast', false); // default false $isVerbose = (bool) $request->getParam('verbose', false); if ($isFast) { // perform a fast query ... } else { // perform standard query ... } } In case of flag alternatives , we have to check each alternative separately: /* * Assuming our route now reads: * 'route' => 'find user [--fast|-f] [--verbose|-v] ... ', */ public function findAction() { $request = $this->getRequest(); // Check both alternatives $isFast = $request->getParam('fast', false) || $request->getParam('f', false); $isVerbose = $request->getParam('verbose', false) || $request->getParam('v', false); // ... }","title":"Console-Aware Controllers"},{"location":"mvc/controllers/#console-aware-controllers","text":"When using the zend-mvc integration with zend-console, a matched route results in dispatch of an action controller. In this chapter we will learn how ZF2 Controllers can interact with and return output to console window.","title":"Console-Aware Controllers"},{"location":"mvc/controllers/#handling-console-requests","text":"Console requests are very similar to HTTP requests. In fact, they implement a common interface and are created at the same time in the MVC workflow. Console routes match against command line arguments and provide a defaults array, which holds the controller and action keys. These correspond with controller aliases in the ServiceManager , and method names in the controller class. This is analogous to the way HTTP requests are handled under zend-mvc. In this example we'll use the following route: // in file module/Application/config/module.config.php: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ 'list-users' => [ 'options' => [ 'route' => 'show [all|disabled|deleted]:mode users [--verbose|-v]', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'show-users', ], ], ], ], ], ], /* ... */ ); This route will match commands such as: $ php public/index.php show users $ php public/index.php show all users $ php public/index.php show disabled users This route maps to the method Application\\Controller\\IndexController::showUsersAction() . Let's add it that method to our controller. <?php namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; class IndexController extends AbstractActionController { public function indexAction() { return new ViewModel(); // display standard index page } public function showUsersAction() { $request = $this->getRequest(); $users = $this->getServiceLocator()->get('users'); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = array(); switch ($mode) { case 'disabled': $users = $users->fetchDisabledUsers(); break; case 'deleted': $users = $users->fetchDeletedUsers(); break; case 'all': default: $users = $users->fetchAllUsers(); break; } } } We fetch the console request, read parameters, and load users from our (theoretical) users service. In order to make this method functional, we'll have to display the result in the console window.","title":"Handling Console Requests"},{"location":"mvc/controllers/#sending-output-to-the-console","text":"The simplest way for our controller to display data in the console window is to return a string. Let's modify our example to output a list of users: public function showUsersAction() { $request = $this->getRequest(); $users = $this->getServiceLocator()->get('users'); // Check verbose flag $verbose = $request->getParam('verbose') || $request->getParam('v'); // Check mode $mode = $request->getParam('mode', 'all'); // defaults to 'all' $users = array(); switch ($mode) { case 'disabled': $users = $users->fetchDisabledUsers(); break; case 'deleted': $users = $users->fetchDeletedUsers(); break; case 'all': default: $users = $users->fetchAllUsers(); break; } if (count($users) === 0) { // Show an error message in the console return \"There are no users in the database\\n\"; } $result = ''; foreach ($users as $user) { $result .= $user->name . ' ' . $user->email . \"\\n\"; } return $result; // show it in the console } In the second conditional, we are checking if the users service found any users; if not, we return an error message to display immediately, terminating the application. If any users are found, we loop through each to prepare a listing, which we then return from the action for display in the console.","title":"Sending Output to the Console"},{"location":"mvc/controllers/#are-we-in-a-console","text":"Sometimes we might need to check if our method is being called from a console or from a web request. This is useful to block certain methods from running in the console or to change their behavior based on that context. Here is an example of how to check if we are dealing with a console request: namespace Application\\Controller; use Zend\\Mvc\\Controller\\AbstractActionController; use Zend\\View\\Model\\ViewModel; use Zend\\Console\\Request as ConsoleRequest; use RuntimeException; class IndexController extends AbstractActionController { public function showUsersAction() { $request = $this->getRequest(); // Make sure that we are running in a console and the user has not tricked our // application into running this action from a public web server. if (! $request instanceof ConsoleRequest) { throw new RuntimeException('You can only use this action from a console!'); } /* ... */ } }","title":"Are we in a Console?"},{"location":"mvc/controllers/#reading-values-from-console-parameters","text":"There are several types of parameters recognized by the Console component, all of which are described in the console routing chapter . Here, we'll focus on how to retrieve values from distinct parameters and flags.","title":"Reading Values from Console Parameters"},{"location":"mvc/modules/","text":"Console-Aware Modules zend-mvc integrates with zend-console; the integration also works with modules loaded with the Module Manager . zend-mvc ships with a console-specific RouteNotFoundStrategy which is responsible for displaying console usage information when: the user has not provided any arguments; or arguments could not be matched by any routes. The strategy currently supports two types of information: application banners and usage information . Application banner When using zend-console within a zend-mvc application, you can invoke it via the application bootstrap: $ php public/index.php By default, it will simply output the current ZF 2 version, like this: Our Application module (and any other module) can provide an application banner . In order to do so, our Module class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return 'MyModule 0.0.1'; } } As you can see, the application banner should be a single line string that returns the module's name and (if available) its current version. If several modules define their own banner, they are displayed one after the other in the order in which the modules are loaded. This allows you to see at a glance which modules expose console commands. If we execute our console application now, we'll see the newly created banner: Let's create and load a second module that provides a banner: <?php // config/application.config.php return array( 'modules' => array( 'Application', 'User', // <- load user module in module/User ), The User module will provide info about itself: // module/User/Module.php <?php namespace User; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return \"User Module 0.0.1\"; } } Because the User module is loaded after the Application module, the result will look like this: Application banner display Application banners provided by modules are displayed as-is \u2014 no trimming or other adjustments will be performed on the text. As you can see, banners are also automatically colorized as blue. Usage information In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our example and add the new method defined in that interface: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface, ConsoleUsageProviderInterface { public function getConsoleBanner(Console $console) { /* ... */ } /** * This method is defined in ConsoleUsageProviderInterface */ public function getConsoleUsage(Console $console) { return [ 'show stats' => 'Show application statistics', 'run cron' => 'Run automated jobs', '(enable|disable) debug' => 'Enable or disable debug mode for the application.', ]; } } This will display the following information: Similar to application banners , multiple modules can provide usage information, which will be joined together and displayed to the user. The order in which usage information is displayed is the order in which modules are loaded. As you can see, the zend-mvc integration also prepends each module's usage with the module's name. This helps to visually separate commands by module \u2014 which is particularly useful when you have multiple modules providing commands. By default, the component colorizes the module names in red. Usage information is arbitrary Usage info provided in modules is not connected with console routing . You can describe console usage in any form you prefer, and it does not affect how MVC handles console commands. In order to handle real console requests, you still need to define console routes. Free-form text In order to output free-form text as usage information, getConsoleUsage() can return a string or an array of strings. As an example, the following is a single, free-form usage text: public function getConsoleUsage(Console $console) { return 'User module expects exactly one argument - user name. ' . 'It will display information for the provided user.'; } Usage text is provided as-is The text provided is displayed as-is; no trimming or other adjustments will be performed. If you'd like to fit your usage information inside the console window, you could check its width with $console-getWidth() . List of commands If getConsoleUsage() returns an associative array, it will be automatically aligned in 2 columns. The first column will be prepended with script name (the entry point for the application). This is useful to display the various commands exposed. public function getConsoleUsage(Console $console) { return [ 'delete user <userEmail>' => 'Delete user with email <userEmail>', 'disable user <userEmail>' => 'Disable user with email <userEmail>', 'list [all|disabled] users' => 'Show a list of users', 'find user [--email=] [--name=]' => 'Attempt to find a user by email or name', ]; } Command list alignment Commands and their descriptions will be aligned in two columns that fit inside the terminal window. If the window is resized, text may wrap, but all content will be aligned. If you don't like the behavior, you can always return free-form text instead, as free-form text is never transformed or aligned. List of params and flags Returning an array of arrays from getConsoleUsage() will produce a listing of parameters. This is useful for explaining flags, switches, possible values and other information. The output will be aligned in multiple columns for readability. As an example: public function getConsoleUsage(Console $console) { return [ [ '<userEmail>', 'email of the user' ], [ '--verbose', 'Turn on verbose mode' ], [ '--quick', 'Perform a \"quick\" operation' ], [ '-v', 'Same as --verbose' ], [ '-w', 'Wide output'], ); } This method can be used to display more than 2 columns of information: public function getConsoleUsage(Console $console) { return [ [ '<userEmail>', 'user email', 'Full email address of the user to find.' ], [ '--verbose', 'verbose mode', 'Display additional information during processing' ], [ '--quick', '\"quick\" operation', 'Do not check integrity, just make changes and finish' ], [ '-v', 'Same as --verbose', 'Display additional information during processing' ], [ '-w', 'wide output', 'When listing users, use the whole available screen width' ], ]; } Alignment All information will be aligned in one or more columns that fit inside the terminal window. If the window is resized, some text may wrap, but all content will remain aligned. In case the number of columns changes (e.g. the array contains different number of elements), a new table will be created, with its own alignment and column widths. If you don't like this behavior, you can always return free-form text . Mixing styles You can use mix together all of the above styles to provide comprehensive usage information. public function getConsoleUsage(Console $console) { return [ 'Finding and listing users', 'list [all|disabled] users [-w]' => 'Show a list of users', 'find user [--email=] [--name=]' => 'Attempt to find a user by email or name', ['[all|disabled]', 'Display all users or only disabled accounts'], ['--email=EMAIL', 'Email of the user to find'], ['--name=NAME', 'Full name of the user to find.'], ['-w', 'Wide output - When listing users use the whole available screen width'], 'Manipulation of user database:', 'delete user <userEmail> [--verbose|-v] [--quick]' => 'Delete user with email <userEmail>', 'disable user <userEmail> [--verbose|-v]' => 'Disable user with email <userEmail>', [ '<userEmail>', 'user email', 'Full email address of the user to change.'], [ '--verbose', 'verbose mode', 'Display additional information during processing'], [ '--quick', '\"quick\" operation', 'Do not check integrity, just make changes and finish'], [ '-v', 'Same as --verbose', 'Display additional information during processing'], ); } Best practices Here are the best practices when providing usage for your commands: Your module's getConsoleBanner() method should return a one-line string containing the module's name and its version (if available); do not provide any other information. Your getConsoleUsage() method should not return the module's name, as it is prepended automatically for you by the zend-mvc integration.","title":"Console-Aware Modules"},{"location":"mvc/modules/#console-aware-modules","text":"zend-mvc integrates with zend-console; the integration also works with modules loaded with the Module Manager . zend-mvc ships with a console-specific RouteNotFoundStrategy which is responsible for displaying console usage information when: the user has not provided any arguments; or arguments could not be matched by any routes. The strategy currently supports two types of information: application banners and usage information .","title":"Console-Aware Modules"},{"location":"mvc/modules/#application-banner","text":"When using zend-console within a zend-mvc application, you can invoke it via the application bootstrap: $ php public/index.php By default, it will simply output the current ZF 2 version, like this: Our Application module (and any other module) can provide an application banner . In order to do so, our Module class has to implement Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface . As an example: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return 'MyModule 0.0.1'; } } As you can see, the application banner should be a single line string that returns the module's name and (if available) its current version. If several modules define their own banner, they are displayed one after the other in the order in which the modules are loaded. This allows you to see at a glance which modules expose console commands. If we execute our console application now, we'll see the newly created banner: Let's create and load a second module that provides a banner: <?php // config/application.config.php return array( 'modules' => array( 'Application', 'User', // <- load user module in module/User ), The User module will provide info about itself: // module/User/Module.php <?php namespace User; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface { /** * This method is defined in ConsoleBannerProviderInterface */ public function getConsoleBanner(Console $console) { return \"User Module 0.0.1\"; } } Because the User module is loaded after the Application module, the result will look like this:","title":"Application banner"},{"location":"mvc/modules/#usage-information","text":"In order to display usage information, our Module class must implement Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface . Let's modify our example and add the new method defined in that interface: // module/Application/Module.php <?php namespace Application; use Zend\\ModuleManager\\Feature\\ConsoleBannerProviderInterface; use Zend\\ModuleManager\\Feature\\ConsoleUsageProviderInterface; use Zend\\Console\\Adapter\\AdapterInterface as Console; class Module implements ConsoleBannerProviderInterface, ConsoleUsageProviderInterface { public function getConsoleBanner(Console $console) { /* ... */ } /** * This method is defined in ConsoleUsageProviderInterface */ public function getConsoleUsage(Console $console) { return [ 'show stats' => 'Show application statistics', 'run cron' => 'Run automated jobs', '(enable|disable) debug' => 'Enable or disable debug mode for the application.', ]; } } This will display the following information: Similar to application banners , multiple modules can provide usage information, which will be joined together and displayed to the user. The order in which usage information is displayed is the order in which modules are loaded. As you can see, the zend-mvc integration also prepends each module's usage with the module's name. This helps to visually separate commands by module \u2014 which is particularly useful when you have multiple modules providing commands. By default, the component colorizes the module names in red.","title":"Usage information"},{"location":"mvc/modules/#best-practices","text":"Here are the best practices when providing usage for your commands: Your module's getConsoleBanner() method should return a one-line string containing the module's name and its version (if available); do not provide any other information. Your getConsoleUsage() method should not return the module's name, as it is prepended automatically for you by the zend-mvc integration.","title":"Best practices"},{"location":"mvc/routing/","text":"MVC Routing zend-mvc provides integration with zend-console, routing command line arguments to the appropriate action controller and action method that will handle the request. Actions can perform any number of tasks prior to returning a result to display in the console window. When using zend-mvc, console routes are provided via configuration. // The following can sit inside of module/Application/config/module.config.php, // any other module's configuration, or within files under config/autoload/: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ // Console routes go here ], ], ], ]; Console routes exposed via zend-mvc will only be processed when the application is run inside a console (terminal) window; they are not used for web (HTTP) requests. It is possible to define only HTTP routes (web application only), only console routes (console-only application), or a mixture of the two. As an example of a single route: // inside config.console.router.routes: 'my-first-route' => [ 'type' => 'simple', // This is the default, and may be omitted; more on // types below 'options' => [ 'route' => 'foo bar', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'password', ], ], ], We have created a simple console route with the name my-first-route . It expects two parameters: foo and bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction() action will be invoked. Route Types In the last example of the previous section, we noted that configuration for a given route can accept a type argument. This refers to the route type (which maps to a class) to use when creating the route instance. zend-mvc defines several types. Simple Route Zend\\Mvc\\Router\\Console\\Simple is a factory for zend-console's DefaultRouteMatcher , and decorates it to work with the zend-mvc routing system. See the section on the default route matcher for details on route strings and available configuration to provide. Catchall Route This special route will catch all console requests, regardless of the parameters provided. 'default-route' => [ 'type' => 'catchall', 'options' => [ 'route' => '', 'defaults' => [ 'controller' => 'Application\\Controller\\Index', 'action' => 'consoledefault', ], ], ], This route type is rarely used; one possible use case is to register it as the last console route, in order to display usage information. Before you do so, read about the preferred way of displaying console usage information ; following recommendations will guarantee proper interoperation with other modules in your application.","title":"MVC Routing"},{"location":"mvc/routing/#mvc-routing","text":"zend-mvc provides integration with zend-console, routing command line arguments to the appropriate action controller and action method that will handle the request. Actions can perform any number of tasks prior to returning a result to display in the console window. When using zend-mvc, console routes are provided via configuration. // The following can sit inside of module/Application/config/module.config.php, // any other module's configuration, or within files under config/autoload/: return [ 'router' => [ 'routes' => [ // HTTP routes are here ], ], 'console' => [ 'router' => [ 'routes' => [ // Console routes go here ], ], ], ]; Console routes exposed via zend-mvc will only be processed when the application is run inside a console (terminal) window; they are not used for web (HTTP) requests. It is possible to define only HTTP routes (web application only), only console routes (console-only application), or a mixture of the two. As an example of a single route: // inside config.console.router.routes: 'my-first-route' => [ 'type' => 'simple', // This is the default, and may be omitted; more on // types below 'options' => [ 'route' => 'foo bar', 'defaults' => [ 'controller' => Application\\Controller\\Index::class, 'action' => 'password', ], ], ], We have created a simple console route with the name my-first-route . It expects two parameters: foo and bar . If user puts these in a console, Application\\Controller\\IndexController::passwordAction() action will be invoked.","title":"MVC Routing"},{"location":"mvc/routing/#route-types","text":"In the last example of the previous section, we noted that configuration for a given route can accept a type argument. This refers to the route type (which maps to a class) to use when creating the route instance. zend-mvc defines several types.","title":"Route Types"}]}